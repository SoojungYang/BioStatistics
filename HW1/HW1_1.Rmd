---
title: '[HW1] Probability Distribution'
name: ' 20170380 Soojung Yang '
date: '2019 9 16 '
output:
  html_document:
    df_print: paged
  html_notebook: default
  pdf_document: default
  word_document: default
---

The goal of this assignment is to analyze NCBI Breast Cancer dataset by Molecular subtypes. The description for the dataset is given below.   

## DATASET  
**NCBI_Build 37 (UCSC hg19)**   
- containing clinical information of 1,055 samples, 90,490 mutations, expression data of 17,814 genes for 527 samples  
- Data was obtained with Illumina GAIIx sequencer with whole exome sequencing method

#### Mutation  
• **Sample_id**: mappable unique sample id of patient.  
• **Hugo_Symbol**: gene symbol provided by HGNC  
• **ensembl_gene_id**: gene id provided by ensembl of EBI  
• **Chromosome**: position of each gene on chromosomes  
• **Variant_Classification**: classification of variants.  
• **Variant_Type**: Deletion, Insertion, or SNP  
• **Mutation_Status**: Somatic or Germline mutation.  

#### Clinical
• **sample_id**: mappable unique sample id of patient.  
• **stage**: pathological state of each patient.   
• **subtype**: subtype of each patient classified by PAM50 classification system.  
• **survival_time**: survival time of each patient after diagnosis of the disease.  
• **vital_status**: vital status of each patient. 1: died, 0: alive.   
• **survival_index**: a class label related to the survival of the patient and could be regarded as a class label of the same type as the stage or subtype.  

***
## Problem
> **1. Calculating 5-year survival probabilities of each subtypes in the clinical dataset except “normal-like” subtype.**

Load datasets.  
```{r}
clinical <- readRDS("~/R/clinical.rds")
mutation <- readRDS("~/R/mutation.rds")
```

Get the list of non-NA subtypes.
```{r}
clinical_subtypes <- unique(clinical$subtype[which(!is.na(clinical$subtype))])
n_subtypes <- length(clinical_subtypes)
clinical_subtypes
```

Calculate the 5-year survival probabilities for each subtype except "Normal-type". First filter out the **clinical dataset** for each subtype, then calculate the 5-year survival probability. 
```{r}
for (i in 1:n_subtypes){
  if (clinical_subtypes[i] != "Normal-like"){
  clinical_subset <- dplyr::filter(clinical, subtype==clinical_subtypes[i])
  tot <- length(which(clinical_subset$survival_time>=0))
  survived <- length(which(clinical_subset$survival_time>1825))
  prob <- survived/tot
  print(paste("5-year survival prob. for ", clinical_subtypes[i], " is: ", round(prob,3)))}
}
```

> **2. Finding Top 10 highly possible driving mutations with estimated probability using conditional probability for each subtype in the clinical dataset.**

#### 1. Estimation using Bayes' Rule

For highly possible cancer-driving mutation genes of each subtype, $p(subtype|gene)$ values would be high. $p(subtype|gene)$ value can be calculated with Bayes' rule.  
$p(S_i|gene) = \frac{p(gene|S_i)p(S_i)}{\sum_{i=1}^{5} p(gene|S_i)p(S_i)}$  
  

Also, following components could be calculated as below.  
For each subtype $S_i$,  
  
$p(S_i) = \frac{\textbf{# samples of subtype i}}{\textbf{total # samples}}$  
  
$p(gene_j|S_i) = \frac{\textbf{# samples of subtype i that have mutation j}}{\textbf{# samples of subtype i}}$  
  
$p(S_i|gene_j) = \frac{\textbf{# samples of subtype i that have mutation j}{total # samples}$

Find total number of sample and number of samples of each subtype.  
```{r}
total_sample <- unique(clinical$sample_id)
total_num_sample <- length(total_sample)
print(paste("total number of sample is ", total_num_sample))

for (i in 1:n_subtypes){
  # calculate p(S_i)
  subset <- clinical$sample_id[which(clinical$subtype==clinical_subtypes[i])]
  assign(paste("subset_",i,sep=""),dplyr::filter(mutation, sample_id %in% subset))
  p_s <- length(subset)/total_num_sample
  print(paste("p(S) for ",clinical_subtypes[i]," is: ", round(p_s,3)))}

subset_na<-clinical$sample_id[which(is.na(clinical$subtype))]
assign("subset_NA",dplyr::filter(mutation, sample_id %in% subset_na))
p_s <- length(subset_na)/total_num_sample
print(paste("p(S) for nontype is: ", round(p_s,3)))

```

 
 
```{r}
# obtain list of mutated genes
mut_gene_list <- unique(mutation$ensembl_gene_id)
n_genes <- length(mut_gene_list)

prob_result_1 <- data.frame(gene=character(), Luminal_A=double(), Luminal_B=double(), Basal_like=double(), HER2_enriched=double(), normal_like=double(), stringsAsFactors = FALSE)

for (j in 1:n_genes){
  gene_id <- mut_gene_list[j]
  prob_result_1[j,1] <- gene_id
  #calculate sigma[p(gene|S_i)*p(S_i)]
  odd_1 <- length(which(subset_1$ensembl_gene_id==gene_id))
  odd_2 <- length(which(subset_2$ensembl_gene_id==gene_id))
  odd_3 <- length(which(subset_3$ensembl_gene_id==gene_id))
  odd_4 <- length(which(subset_4$ensembl_gene_id==gene_id))
  odd_5 <- length(which(subset_5$ensembl_gene_id==gene_id))
  odd_na <- length(which(subset_NA$ensembl_gene_id==gene_id))
  sigma <- (odd_1+odd_2+odd_3+odd_4+odd_5+odd_na)/total_num_sample
  
  # calculate p(S_i|gene) from Bayes' rule
  divisor <- total_num_sample*sigma
  prob_result_1[j,2] <- odd_1/divisor
  prob_result_1[j,3] <- odd_2/divisor
  prob_result_1[j,4] <- odd_3/divisor
  prob_result_1[j,5] <- odd_4/divisor
  prob_result_1[j,6] <- odd_5/divisor
}
```


#### 2. Direct calculation of p(subtype|gene)  
We can directly calculate $p(S_i|gene_j)$ without using Bayes' rule as follows.  
$p(S_i|gene_j)=\frac{\textbf{# samples of subtype i with gene j mutated}}{\textbf{# samples with gene j mutated}}$

```{r}
prob_result_2 <- data.frame(gene=character(), Luminal_A=double(), Luminal_B=double(), Basal_like=double(), HER2_enriched=double(), normal_like=double(), stringsAsFactors = FALSE)

for (j in 1:n_genes){
  gene_id <- mut_gene_list[j]
  # calculate the number of samples with mutation gene j
  sample_with_mut <- dplyr::filter(mutation, ensembl_gene_id==gene_id)
  sample_id_with_mut <- unique(sample_with_mut$sample_id)
  clinical_filtered<-dplyr::filter(clinical,sample_id %in% sample_id_with_mut)
  tot_sample <- nrow(clinical_filtered)
  prob_result_2[j,1] <- gene_id
  
  # calculate the number of samples with mutation gene j and subtype i 
  for (i in 1:n_subtypes){
    subtype_sample <- length(which(clinical_filtered$subtype==clinical_subtypes[i]))
    prob <- subtype_sample/tot_sample
    prob_result_2[j,1+i] <- prob
  }
}

```

Obviously, Method 1(Bayes' rule) and Method 2(direct calculation) show same result. However, calculation of Method 1 took less time. 

#### Method 1 result  
```{r}
head(prob_result_1,20)
```

#### Method 2 result  
```{r}
head(prob_result_2,20)
```

## Result 

#### TOP 10 driving mutations for each subtype  
```{r}
dplyr::select(head(prob_result_1[order(-prob_result_1$Luminal_A),],10),gene,Luminal_A)
```
```{r}
dplyr::select(head(prob_result_1[order(-prob_result_1$Luminal_B),],10),gene,Luminal_B)
```
```{r}
dplyr::select(head(prob_result_1[order(-prob_result_1$Basal_like),],10),gene,Basal_like)
```
```{r}
dplyr::select(head(prob_result_1[order(-prob_result_1$HER2_enriched),],10),gene,HER2_enriched)
```
```{r}
dplyr::select(head(prob_result_1[order(-prob_result_1$normal_like),],10),gene,normal_like)
```


## Discussion  

Since the number of samples that has each mutated gene was very small (1~7), there was a high probability for all samples for each gene having the same subtype. This made the probabilities $p(subtype_i|gene_j)$ to be 1 so easily.
Because of this limitation, it is difficult to conclude that the shown Top 10 genes are the highest cancer-driving mutation genes.  
  
Method 1 took less time compared to Method 2. It would be interesting to further compare the computational cost of R function such as 'dplyr::filter', 'which', 'unique', etc.

## References  
* Tutorial Manual (provided by the lecturer)  

***
**This report is written with R Markdown** 
